Бинарный поиск

Алгоритм поиска, используемый для поиска определенного элемента в отсортированном массиве.

Шаг 1: Установите два указателя: один в начале списка и один в конце списка.
Шаг 2: Вычислите среднее положение между левым и правым указателями и сравните элемент в средней позиции с целевым элементом.
- Если элемент в средней позиции соответствует целевому элементу, поиск успешен и возвращается позиция (индекс) целевого элемента.
- Если средний элемент больше целевого элемента, удалите правую половину пространства поиска, переместив правый указатель на одну позицию перед средним.
- Если средний элемент меньше целевого элемента, удалите левую половину пространства поиска, переместив левый указатель на одну позицию после середины.
Сложность: O(log n)

|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

Ternary Search

Алгоритм поиска элемента в упорядоченном массиве.

Алгоритм:
Начинаем сравнивать искомое значение с элементами на двух точках деления:
- Если искомое значение меньше значения на первой точке деления, то поиск продолжается только в первой трети массива.
- Если искомое значение больше значения на первой точке деления, но меньше значения на второй точке деления, то поиск продолжается во второй трети массива.
- Если искомое значение больше значения на второй точке деления, то поиск продолжается только в третьей трети массива.
- Если искомое значение равно значению на одной из точек деления, то поиск заканчивается, и эта позиция возвращается как результат.
- Если искомое значение не найдено в массиве, то поиск продолжается до тех пор, пока длина промежутка не станет равной 0.

Сложность: O(log3 N)

|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

Jump Search

Алгоритм поиска элемента в упорядоченном массиве, который переходит через определенное количество элементов на каждой итерации для нахождения нужного значения.

Алгоритм:
Начинаем сравнивать искомое значение с элементом на каждом шаге, прыгая через фиксированное количество элементов.
- Если искомое значение меньше значения на текущей позиции, поиск вернется назад на фиксированное количество шагов и продолжит поиск в предыдущем интервале элементов.
- Если искомое значение больше значения на текущей позиции, поиск продолжится дальше, прыгая через фиксированное количество элементов.
- Если искомое значение равно значению на текущей позиции, то поиск заканчивается, и эта позиция возвращается как результат.
- Если искомое значение не найдено в массиве, алгоритм продолжает прыгать и сравнивать, пока не будет найдено значение или пока превысит размер массива.

Сложность: O(sqrt(n))

||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

Интерполяционный поиск

Алгоритм поиска элемента в упорядоченном массиве, который использует интерполяцию для приближенного нахождения позиции искомого значения.

Алгоритм:
Шаг 1: В цикле вычислите значение «pos», используя формулу положения датчика.
Шаг 2: Если это совпадение, верните индекс элемента и выйдите.
Шаг 3: Если элемент меньше arr[pos], вычислите положение зонда левого подмассива. В противном случае вычислите то же самое в правом подмассиве.
Шаг 4: Повторяйте до тех пор, пока не будет найдено совпадение или пока подмассив не уменьшится до нуля.

Сложность: O(log(log(n)))

||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

Поиск Фибоначчи

Метод, основанный на сравнении, который использует числа Фибоначчи для поиска элемента в отсортированном массиве.

Последовательность Фибоначчи начинается с чисел 0 и 1, а каждое следующее число равно сумме двух предыдущих чисел. Вот первые несколько чисел последовательности: 0, 1, 1, 2, 3, 5, 8, 13 и т.д.

Сложность: O(log n)
